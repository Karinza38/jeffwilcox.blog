---
layout: post
comments: true
title: Visual Studio unit testing intro
wordpress_id: 94
wordpress_url: http://www.jeff.wilcox.name/2008/08/16/utbasics/
imported_categories:
- title: software-development
  slug: dev
  autoslug: software-development
- title: silverlight
  slug: silverlight
  autoslug: silverlight
- title: testing
  slug: testing
  autoslug: testing
- title: microsoft
  slug: microsoft
  autoslug: microsoft
imported_link_categories: []
tags: []
---
<p>Visual Studio's unit testing framework isn't widely covered in books or in other places, and this makes it tougher for teams to adopt strict test guidelines for their developers. At the end of the day, if you aren't unit testing from day one of your project, you're in for a world of hurt down the line.</p> <p>If you've new to Visual Studio unit testing, or just wanting to learn about Silverlight unit testing, you may feel a little lost. Here's some information that just scratches the surface of the Visual Studio unit testing world.</p> <p>So here are some of the questions people may have, let me know if there are others that you have! If you're already familiar with unit testing this will all be redundant.</p> <h3>What makes up a unit test project?</h3> <p>Most unit tests are simple class libraries written in your language of choice. They reference your production application's projects or built assemblies, and also the unit test framework.</p> <p><img src="http://media.jeff.wilcox.name/blog/ut/UnitTestBasics.png"/> </p> <p>Metadata decorates the tests, and the tests themselves typically include calls to the test framework's assertion classes.</p> <h3>Where do I go to get started?</h3> <p>Must-read resources:</p> <ul> <li><a href="http://msdn.microsoft.com/en-us/library/ms243147.aspx">MSDN: Unit Testing Framework</a> (One page that covers just about all the metadata)</li> <li><a href="http://msdn.microsoft.com/en-us/library/ms182530.aspx">MSDN: Using the Assert Classes</a></li> <li><a href="http://msdn.microsoft.com/en-us/library/microsoft.visualstudio.testtools.unittesting.assert_methods.aspx">MSDN: The most common Assert methods</a></li> <li><a href="http://msdn.microsoft.com/en-us/library/ms182517.aspx">MSDN: Structure of Unit Tests</a></li> <li><a href="http://weblogs.asp.net/stephenwalther/">Stephen Walther</a> does a <a href="http://weblogs.asp.net/stephenwalther/archive/2008/03/19/tdd-test-driven-development-with-visual-studio-2008-unit-tests.aspx">very detailed walkthrough of unit testing</a>, with an emphasis on testing ASP.NET MVC code</li></ul> <p>Patterns and examples:</p> <ul> <li>The <a href="http://www.codeplex.com/CompositeWPF">Composite WPF guidance</a> by Microsoft's Patterns &amp; Practices includes tests</li> <li>TypeMock has a useful, general article about <a href="http://www.typemock.com/Docs/TestPatterns.html">unit testing patterns</a>. Note that their examples aren't using the Visual Studio metadata, but instead nUnit's... but it's pretty much the same.</li></ul> <p>Videos:</p> <ul> <li><a href="http://www.asp.net/learn/vsts-videos/video-126.aspx">Eric Lee</a> has an 11 minute screencast <a href="http://www.asp.net/learn/vsts-videos/video-126.aspx">walkthrough of unit testing</a> basics inside Visual Studio</li></ul> <p>For testing desktop applications, class libraries, and other code built for the full .NET framework, you're in for a treat: Visual Studio 2008 Professional and other SKUs put great built in unit test support right inside your development environment. You'll always be a click away from running a test or seeing where you stand.</p> <h3>What's a unit test?</h3> <ul> <li>Simple.  </li><li>Quick to run. </li><li>Independent and self-contained: Should not rely on any previous test results or any particular execution order.  </li><li>Doesn't cross any <a href="http://haacked.com/archive/2008/07/22/unit-test-boundaries.aspx">unit test boundaries</a> (as defined by <a href="http://haacked.com/Default.aspx">Phil Haack</a>) </li><li>Easy to maintain over time. Documented. Not archaic. </li><li>Lacking variability: a valid unit test should always consistently pass. </li><li>Positive or negative: They can validate exceptions and error conditions as well as expected results and states.</li></ul> <h3>What isn't a unit test?</h3> <ul> <li>A test that validates integration (your database and your class library).</li> <li>A test that interacts with UI, network resources, or the file system.</li> <li>Something that takes a long while to run.</li> <li>An end-to-end test of a user scenario.</li> <li>A performance, stress, load test, security, or other advanced test.</li> <li>Complex.</li></ul> <h3>What other kinds of tests are written?</h3> <p>There are integration tests, end-to-end tests, performance and stress tests, and many, many more. But at Microsoft I like to think of tests in 3 sets. In some cases it is possible for all the tests in a product to build upon a 'unit test framework'.</p> <p><strong>Unit</strong>: "True" unit tests. Quick, small, efficient, very useful to always run. Independent.</p> <p><strong>Developer</strong>: Unit tests plus tests that exercise simple scenarios and conditions, such as the control framework in WPF, or performing a super simple request. Often these reach outside of the typical "unit test boundaries," but are still quick to run and useful.</p> <p>Developers are typically required to run all of the developer tests on their machine when preparing a check-in to validate the state of the code.</p> <p><strong>All tests</strong>: The set of all developer tests and everything that the test development team has created. Sometimes reaches into the tens of thousands of scenarios and cases at the end of a product cycle once a matrix of platforms and configurations is taken into consideration.</p> <p>Developers and testers work together to make sure that all tests are run regularly, and especially when working on approaching a major product milestone, release, or servicing activity.</p> <h3>Why would you use a unit test framework to create more than unit tests?</h3> <ul> <li>Consistency.</li> <li>Can usually run many integration and scenario tests in the same test runs.</li> <li>Run integration tests on many platforms in an automated fashion using test controllers and harnesses.</li> <li>The definition of a unit test is pretty academic. At the end of the day, I want to get my job done efficiently and without needing to continually learn new systems. So doing more than true "unit testing" is cool with me.</li> <li>Allow your developers and test developers to share experience, test cases, and help each other succeed.</li></ul> <h3>Why does the Silverlight unit testing framework have tests that look just like the full desktop framework's? Are they the same? </h3> <p>When building out the <a href="http://www.jeff.wilcox.name/2008/03/31/silverlight2-unit-testing/">Silverlight unit test system</a> that runs tests inside of your web browser, we made the call to reuse Visual Studio's unit test framework metadata. This is a great win, for a few reasons:</p> <ul> <li>Reuse of existing tests: many simple API tests can be run as they are.  </li><li>Many .NET developers already know Visual Studio's unit test framework, or nUnit. No need to waste time learning the basics of another system. </li><li>If you're new to Microsoft's unit testing framework in general and starting with Silverlight, you'll walk away with the information you need to start unit testing in Visual Studio as well.  </li><li>Why re-invent the wheel?</li></ul> <h3>I like the Silverlight test framework, but how can I make sure that my tests can be ported to a desktop Windows Forms, class library, or WPF project?</h3> <p>Make sure that your unit tests are actually small, independent, simple, and not dependent on the web browser, Silverlight itself, or the more advanced "beyond unit testing" capabilities that are also present in Microsoft.Silverlight.Testing. If you inherit from the "SilverlightTest" base class, you probably have a test that won't port to the desktop .NET framework.</p> <p>We've worked hard to provide a subset of the full Visual Studio unit test metadata, but here's a quick guide for you:</p> <p><strong>OK to use in both worlds:</strong></p> <ul> <li>All the metadata attributes including TestClass, TestMethod, ClassInitialize, ClassCleanup, TestInitialize, TestCleanup, AssemblyInitialize, AssemblyCleanup, Ignore.</li> <li>StringAssert, Assert, CollectionAssert static types.</li></ul> <p><strong>Desktop features that will not work with the Silverlight test framework today (or are no-ops):</strong></p> <ul> <li>Data-driven tests</li> <li>TestContext</li> <li>File-based assertions and accessing the file system</li> <li>Using WorkItem or TestProperty attributes</li> <li>Web/ASP.NET test functionality.</li> <li>DeploymentItem.</li></ul> <p><strong>Silverlight test features that will not port to the desktop:</strong></p> <ul> <li>Using Silverlight or web browser features.</li> <li>Inheriting from the SilverlightTest base class.</li> <li>Using any of the Silverlight "TestSurface" or TestPanel features exposed by the SilverlightTest base class.</li> <li>Using the "Asynchronous" features in the framework, including the Enqueue and test work item / test task features.</li> <li>Using any of the attributes defined in the Microsoft.Silverlight.Testing namespace, such as AsynchronousAttribute, BugAttribute, and ExclusiveAttribute.</li> <li>Writing your own UnitTestProvider, your own Harness, or your own UnitTestHarness</li> <li>Writing your own test tasks and work items.</li></ul> <p>Hope this helps get some of you started!</p>
