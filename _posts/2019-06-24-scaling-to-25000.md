---
layout: post
comments: false
title: "Scaling from 2,000 to 25,000 engineers on GitHub at Microsoft"
categories: [microsoft, open-source]
tags: [tech, github, opensource, scale, ospo, compliance, nodejs]
neighborhood: "BUILDING 17"
location: "REDMOND, WA USA"
---

At Microsoft today we have about 25,000 engineers participating in our official
GitHub organizations for open source, as well as contributing to open source
communities throughout GitHub.

In sheer numbers, we're operating at 10X the scale we were when I posted in 2015 about our
early experience [scaling from 20 to 2,000 engineers](https://jeffwilcox.blog/2015/11/azure-on-github/)
in the open source org at [https://github.com/azure](https://github.com/azure).

Now feels like a good time to share more of the experiences
I've had as a member of Microsoft's Open Source Programs Office (OSPO) as we have
matured, grown and scaled this effort together.

In this post, I will cover:

- Core principles we have adopted with our open source and GitHub experience
- Technical investments we have made to scale
- Program investments of note
- Key learnings
- Looking to the future
- Resources including the open source projects mentioned in this post

I'm focusing more on the tactical approach we took to enabling GitHub at scale
than I am on the cultural learnings or any specific project's experience -
though I hope we can help amplify and share the experiences projects have
been having. I'd love to hear from teams coordinating projects including
[Terminal](https://github.com/microsoft/terminal),
[TypeScript](https://github.com/microsoft/typescript),
[Accessibility Insights](https://accessibilityinsights.io),
[Windows Calculator](https://github.com/microsoft/calculator)
etc. around their experiences. We work hard to build the right
experiences so that engineers have everything they need, without our office
getting in their way.

It should be no surprise that open source is a big part of what has helped us to
scale and to give back:

- we've adopted CLA Assistant, open sourced by SAP, and now contribute to the same project, after throwing away our home-built, aging solution for Contributor License Agreements (CLAs)
- our self-service GitHub management tooling is open source
- we're using an open source attribution engine built by Amazon
- we're collaborating together on Clearly Defined, an OSI project, to crawl all the open source projects we can find to discover license, copyright, and other data... curating that data in the open on GitHub, making all that collective data available
- our team has even invested in moving to more common open services and systems such as containers and Postgres and MongoDB to make it easier to collaborate with other companies and stacks
- we regularly use [VS Code](https://github.com/microsoft/vscode), [TypeScript](https://github.com/microsoft/TypeScript), [Kubernetes](https://github.com/kubernetes/kubernetes), [Webpack](https://github.com/webpack), and thousands of open libraries.

Looking forward, we have a lot more work to do to focus on developing our
capabilities - evolving our maturity models around what healthy and awesome
projects look like, helping graduate work into the community and to
foundations, and continuing rapid iteration, experiments, and learning from
all of this.

I'm so excited to see where we are at in another few years, and encouraged by
the collaboration happening on open source projects across the industry, the
developing communities around specific Microsoft technologies, and all the
random contributions that Microsoft engineers are making to open source all over
GitHub as their teams take dependencies on and get involved in the associated
communities.

# Principles we've adopted

To encourage the best behaviors and help teach Microsoft employees how to use
GitHub and participate in communities, we've identified a number of tenants or
principles that we try and use in everything that OSPO does specific to our
tooling.

## Transparency

Open source centers around collaboration, but one of the challenges today with
GitHub orgs full of many repos is identifying what teams have access to accept
pull requests or administer settings.

While GitHub shows a lot of this data if you start with the Teams view in an org
and drill into a specific team, there's no view for a given repo's teams, unless
you're an admin for that repo.

For all of our repos, releases and reviews,

- Our portal exposes the given teams that control each repo
- All the release requests and data are stored in work items available to any employee
- Our portal for GitHub management shows all GitHub Teams, including 'secret' or hidden teams
- We enable cross-org search in our portal, to more easily locate similarly-named teams and repos across orgs, reducing confusion and internal support costs

## Eliminate / Simplify

If at all possible, we'd rather remove complexity and process and steps. It's not
always possible, but if we continually ask questions of how we approach workflows
and guidance, hopefully we'll test the edges and eliminate where possible.

## Self-service

We'd rather not be a roadblock on operations at all. The traditional GitHub model
involves needing to be invited by username or e-mail to each GitHub organization.

For any employee, we allow automatic self-service join by automating the sending and
accepting of invitations behind the scenes, managed by our portal.

Whenever possible, we want to provide documents, guidance, and other reusable resources,
instead of having to rely on special knowledge or process that has manual steps.

## Delegation

We're advisors, trust our peers and the many businesses at the company, and hope
that our advice, information and tools are well-respected. We try and not stand
in the way of teams doing what they need when possible.

Decisions such as whether to release open source go through a question/answer
experience, and the outcome is either automatic approval, or a business approval
workflow that kicks off, allowing an individual team's business and legal
representatives handle work closest to them.

## Authentic GitHub

Engineers should learn how the GitHub interface works, how pull requests and
reviews, issues, forks, organization teams, and collaborators function.

Whenever possible, we hope that our users go directly to GitHub to manage their
teams, configure team maintainers, welcome new community members into their
projects as maintainers or contributors.

While we do have separate internal interfaces and tools, these help support the
native experience when possible, and we also use tools such as a browser
extension that we share with our users to help light up GitHub with hooks into
our internal tools or guides when needed.

This causes some confusion, compared with many traditional engineering practices
at Microsoft, where a new hire might apply for a single role-based access group,
or automatically get added to a security group on their first day, automatically
getting access to key systems, potentially even direct commit or write access.

We'd much rather our engineers learn about the fork-and-pull request model of
working on GitHub... contributing to another Microsoft open source project
should never require any special permissions, our engineers should just feel
comfortable submitting a pull request and taking it from there.

If someone does have a need to become a repository administrator or to get
permission to merge pull requests, then they should just go ahead and use the
GitHub user interface to request to join an appropriate team. As a result,
engineers learn about what GitHub teams are, the role of a team maintainer in
making delegated decisions, and how to think about the evolution of their
project and its permissions.

# Technical investments

Whenever possible we want to use open source to make open source better and
share that back with the world.

As we have grown by an order of magnitude and rolled our tooling out to
all of Microsoft, we have had to invest in specific areas to either
duct-tape around missing functionality, address mistakes and learnings we
all have, and work to stay on top of enabling our engineers to be
successful and work efficiently.

_I love focusing on the technical work that we have done, though remain
hopeful that as more companies explore open source at scale, and products
such as GitHub Enterprise Cloud evolve, that these sorts of features will
come more naturally to the marketplace, letting people like me focus more
on the human and program aspects of open source, and less on technical
implementation details, or running services._

## Adopting CLA Assistant

We host instances of an open source project for Contributor License Agreement (CLA)
management, integrated with GitHub, called
[CLA Assistant](https://github.com/cla-assistant/cla-assistant)
for Microsoft and the .NET Foundation.

CLA Assistant is an open source project that was started by SAP (yeah, another
big company, sharing!) and is licensed Apache 2.0.

Like many things in the open source program space, working together is ideal,
and so we have not only adopted the project, but also contributed a number of
changes to help with scale issues and rate limiting, automatic signing for
when employees join and leave the company, and are now looking to also adopt
a class of Corporate CLA / CCLA thanks to contributions made by others to the
upstream project.

We migrated from an in-house Contributor License Agreement (CLA) bot
that was originally deployed in 2017. I really liked how the
[VSCode team messaged this to their community with a GitHub issue](https://github.com/Microsoft/vscode/issues/34239) (#34239)
and were able to inform and involve their maintainers of that change.

Once the CLA for an entity is signed once by a community member, they can then
contribute to all other repos, so it's really a relatively low burden that helps
keep our lawyer friends happy.

Some other nice benefits of this system for us:

- Uses modern features such as Status Checks to indicate the state
- Allows us to simplify the UI and no longer use GitHub issue labels to mark CLA status
- Org-level webhook integration means that the CLA is "always-on", with no need to specifically onboard new repos or worry about whether repos are protected

## Data and Insights

GitHub provides useful information including traffic stats, contributor info and
other breakdowns at the repository level.

Across Microsoft's open source projects, however, we have a need to be able to slice
and dice data looking for trends over time, analyzing investments at scale, and so realized
early on that we needed to import all of the available data we can from our GitHub
open source releases into our own big data systems such as Azure Data Lake and Azure Data Explorer.

[Newer GitHub Enterprise Cloud features](https://github.blog/2019-05-23-build-like-an-open-source-community-with-github-enterprise/) look
to help provide organization insights, and we're super excited to give those a
try to augment the other data and insight methods we are using today.

### GHTorrent

Our team is one of the sponsors of the [GHTorrent Project](http://ghtorrent.org/),
an effort to create a scalable, queriable, offline mirror of data offered through
the GitHub REST API. The repo is at [github.com/gousiosg/github-mirror](https://github.com/gousiosg/github-mirror).

This data, similar to GHArchive, helps learn about the broad collaboration
happening on GitHub.

We donate cloud compute resources to the project run by [Georgios Gousios](http://gousios.org/)
who kicked off the project with ideas and collaboration with [Diomidis Spinellis](http://spinellis.gr/).

At Microsoft, we ingest the data into Azure Data Lake to be able to run
interesting queries and learn more about trends and happenings beyond our
campus.

### GHCrawler

[GHCrawler](https://github.com/microsoft/ghcrawler) is a robust GitHub API
crawler that walks a queue of GitHub entities transitively, retrieving and storing
their contents. The initial project launched in 2016 and evolved significantly
at the [TODO Group tools hackathon in June 2017](https://todogroup.org/blog/todo-tools-hackathon/)
while working with other companies to abstract the data stores to support
other technologies and stacks.

The crawler taught us _a lot_ about the GitHub API and how to be friendly
citizens by focusing on the caching of entities, the use of e-tags, and being
careful to not repeatedly fetch the same resource.

Different from GHTorrent, the crawler is able to traverse Microsoft's own open
source organizations using tokens that can peer into our current GitHub team
memberships, retrieve info about maintainers, configuration, and private repos,
and so is very useful in answering operational questions about the growth of
GitHub at Microsoft.

We ingest the data from GHCrawler into both Azure Data Lake
[Azure Data Explorer](https://azure.microsoft.com/en-us/pricing/details/data-explorer/)
and use that data in Power BI dashboards and reports, live data display on
internal sites, and other resources.

Since the data comes from GitHub but is stored internally, teams can make use
of the data for their own business needs and interests, without having to worry
about GitHub API rate limiting, the specifics around collecting that data, and
just being able to focus on using the data effectively to solve business
problems.

A favorite resource for many teams looking to build new communities is the
data around pull requests and issues, and also collected traffic API data. Since
GitHub only provides a 2-week window of consolidated traffic info, storing the
data in our big data tools helps us look at trends more easily.

## ClearlyDefined

[ClearlyDefined](https://clearlydefined.io/about) is an
[Open Source Initiative (OSI)](https://opensource.org/) project
that has a mission to help FOSS projects thrive by being "clearly defined". The
lack of clarity around licenses reduces engagement that ends up meaning fewer
users, fewer contributors, and a smaller community.

Communities choose a license for their project with the terms that they like.
Defining and knowing the license for an open source project is essential to
a successful community partnership, and so ClearlyDefined helps clarify that
by identifying key data such as license set, attribution parties, code
location, and when the data is missing, curation can help.

Microsoft's OSPO team
contributes to the effort and is making use of the data to help provide license
clarity in the tooling used to help teams understand their use of open source.

As of June 2019, [ClearlyDefined has over 6.3 million definitions](https://clearlydefined.io/stats). These
definitions are created by running tools such as [licensee](https://github.com/licensee/licensee),
[scancode-toolkit](https://github.com/nexB/scancode-toolkit), and
[fossology tools](https://github.com/fossology/fossology) at scale.

## repolinter

Another TODO Group project we collaborate on is [repolinter](https://github.com/todogroup/repolinter).

Given a source repository, you can run repolinter to learn basic information
that can help inform whether a project has all that is necessary to incubate
and build a healthy community, such as

- license files
- README files
- Code of Conduct, governance or contribution information
- No binaries
- Licenses detectable by licensee
- Source headers have license information

From the repo README itself, here's an example of running the `repolinter` tool
on a repo, and the output:

```
git clone https://github.com/todogroup/repolinter
npx repolinter
✔ license-file-exists: found (LICENSE)
✔ readme-file-exists: found (README.md)
✔ contributing-file-exists: found (CONTRIBUTING)
✔ code-of-conduct-file-exists: found (CODE-OF-CONDUCT)
✔ changelog-file-exists: found (CHANGELOG)
✔ readme-references-license: File README.md contains license
✔ binaries-not-present: Excluded file type doesn't exist (**/*.exe,**/*.dll)
✔ license-detectable-by-licensee: Licensee identified the license for project: Apache License 2.0
✔ test-directory-exists: found (tests)
✔ integrates-with-ci: found (.travis.yml)
✔ source-license-headers-exist: The first 5 lines of 'index.js' contain all of the requested patterns.
...
✔ github-issue-template-exists: found (ISSUE_TEMPLATE)
✔ github-pull-request-template-exists: found (PULL_REQUEST_TEMPLATE)
✔ package-metadata-exists: found (Gemfile)
✔ package-metadata-exists: found (package.json)
```

## oss-attribution-builder

We've also collaborated with Amazon to use their
[amzn/oss-attribution-builder](https://github.com/amzn/oss-attribution-builder) project to
help build open source license notice files to help teams meet their legal
obligations.

## 1ES Open Source Assistant Browser Extension

What started as a weekend hack has become an internal browser extension that
lights up GitHub with Microsoft-specific information and guidance. By
highlighting other Microsoft employees on GitHub, people who use the extension
are able to dedicate additional focus on a good collaboration experience with
the community, while easily being able to better identify their coworkers on
GitHub.

Since a GitHub username may not be related to a person's recognized corporate
identity, the extension lights up this data inline throughout GitHub.

The extension helps people to continue to use the native GitHub experience,
while augmenting bits and pieces where we've made decisions around our GitHub
org settings, such as disabling New Repo creation direct on GitHub.

The extension also is also to provide links to policy around open source,
link to the 'new repository' wizard, and even add a 'Join' button to organizations
where the user is not yet a member, but we've enabled employees to self-service
join the org.

The extension works Firefox, Chrome, and the new Edge based on Chromium.
Microsoft employees can learn more and install the extension at [aka.ms/1esassistant](https://aka.ms/1esassistant).

While this extenson is not open source today, if others think it could help
their organization, we will see what we can do.

## Regular automation jobs

We've implemented jobs that do everything from keeping data and caches up-to-date to
helping make sure that we have confidence in the membership of our GitHub organizations.

### Removing former employees

We have jobs connected to internal data sources that help us understand when
an employee has left the company. In a big company, people are always changing
roles, trying new things, and sometimes they leave for other opportunities.

We "unlink" people when they leave: removing the association between their GitHub
account and their corporate identity, and also removing their GitHub organization
membership(s).

We also send an e-mail to their former manager, so they have confidence that the
right things have happened with permissions and system access.

### Enforced "System Teams"

To help enable operations, support, meet security obligations, and light up bots
such as our CLA system, we have a set of GitHub teams that are _automatically_
and _permanently_ added to every repository in our GitHub orgs, when the job is
configured.

By monitoring the GitHub event bus, the job adds what we call *system teams* to
a repo the instant a new repo is created. And, if a repo admin tries to remove
or change the permissions that such a system team has, the job automatically
restores its permission.

An occassional cronjob also runs to validate and reenforce these teams as needed.

### Preventing big permission grants

As the number of members in a GitHub organization grows high, you'll also start
to see very large teams.

We have teams such as "All Employee Members" that are designed to give easy read
access to private repos that are being finished up and polished before going open
source.

An unintended side effect we found: some people wanted to just give "all members"
administrative access over their repo, to make the act of onboarding get much
easier.

Trouble is, with admin comes great power, and any of the thousands of members of
the org could then delete the repo, change whatever they want, override branch
protections, etc.

This also would automatically subscribe thousands of people
to spammy notification messages, depending on their GitHub notification
preferences.

As a result, we have a "large permissions" job that monitors for grants of write or
admin access to an org-defined "large" number of people. Once such a grant is made,
and the team is too large, the job will automatically downgrade the permissions to
try and prevent mistakes, and then send an e-mail address to the person who
made the permission choice, hoping to educate them about the risks and help them
understand what changes were made.

### GitHub username changes

GitHub allows users to change their username. This is excellent: many people start
with a cute screen name or other indicator, then realize they're professionally
developing software with their peers in the industry, and often want to change that
username.

Not all users know that they can rename their account, so we do get people who delete
an account, just to create a new one.

However, the majority of GitHub apps and APIs work off of GitHub _usernames_ instead of
the integer-based _user ID_.

To help stay ahead of this, we have a cronjob that looks up GitHub users by _ID_ and then
refreshes our internal data store of those usernames, in the hope that we can improve
the API success rate and reduce support costs when renames happen.

For critical operations, additional logic has been added to GitHub apps to anticipate
the potential of a user rename happening, and being able to smartly attempt to fallback to
looking up the user first by ID, or alerting and sending the issue to operational support.

### Weekly and daily digests

We have a cronjob that sends updates about new changes and interesting happenings on
GitHub repos. These are typically only send to repo admins, to not spam too many
people.

The digests are personalized to the receipient, and cover scenarios such as:

- notifying the creator of a repo, and their manager, of the new repo
- notifying when the # of admins becomes rather high, so that team maintainers can cleanup permissions
- abandoned repos that haven't been touched in years
- when a team is down to a single maintainer, suggesting they appoint another maintainer or two
- when a repository has been flipped from private to public

## GitHub management portal

Our GitHub management portal for employees to use,
[detailed in my 20105 post on the portal](https://jeffwilcox.blog/2015/11/azure-on-github/),
handles:

- self-service org joining for employees
- cross-organization search of people, repos, and teams
- supports jobs to help maintain at scale

The portal itself is open source and has been rebuilt and refactored over the
past few years to try and be more useful and to allow other companies to use it:

- Node service and site, now implemented in TypeScript
- Backing stores supported include Postgres and others backed by interfaces
- An out-of-the-box "run local in memory" experience is now available

The repo is on GitHub at [microsoft/opensource-portal](https://github.com/microsoft/opensource-portal).

## New repo wizard

While we have a very liberal and friendly policy to make it easy for an
engineering team to decide to share some code such as a sample, we do want to
make sure that there's a process in place that includes a business decision and
legal team approval if there's a major release being considered.

Microsoft has chosen to turn off the "Allow Members to Create Repositories" option
on our open source GitHub organizations.

Instead, we have our own "new repository wizard" within our GitHub management
tooling. This site collects information about the purpose of the repo, the
common GitHub Team permissions that will help a group of engineers get off and
running, and then populates the repo with the standard Microsoft open source
content such as Code of Conduct info in the README, an appropriate LICENSE file
for the project, and the original purpose and use of the repo, for data reporting
purposes internally.

To make this experience easier to find, we work to educate people through
documentation and tools such as the previously mentioned Open Source Assistant
web browser extension. The extension is able to light up the green "new repo" button
on our orgs and link directly to the wizard, providing a better user experience
than the "you have insufficient permission to create a new repository" message
that our users would receive on GitHub otherwise.

The outcome of the repo wizard will be the creation of a public or private
repo on GitHub.

We ask, by policy, that teams only use our open source GitHub orgs for work
they are going to ship within the next 30 days.

## Release reviews

The outcome of the _new repo wizard_ is either auto-approval to make a project
public, or the kick-off of a business and legal review process, to help comply
with policy, and inform leaders about important open source decisions that are
being made.

We have an internal service called the Usage Service that creates a work item
in our work item tracking system (Azure DevOps Boards), and assigns that work
item to the appropriate legal and business reviewer. The work item is then
passed along, with fields or more info being filled out, discussions are had, and
eventually the review will be "final approved" and ready for teams to ship their
project to the world and go build that open community.

After the final approval, an automated e-mail is sent to the original requester
with any guidance from the various reviewers involved in the process, to help
them understand any notifications, legal obligations, or other work that needs
to be done to support their release.

# Program investments

More important than the technical tools and hacks we put in place, the programs
that we run in the Open Source Programs Office help drive process improvements,
awareness of features and capabilities, roll out new functionality, and to
emphasis the work that is happening in the open in new ways.

Here's a set of the OSPO investments we have been making or put in place to help
drive improvement in the open source maturity level of the company.

## Docs

We have a central documentation repository that is easily accessible to employees
where they can read through guides on how to go about releasing open source, or
contributing to it. The hope is that teams new to many of the tools and approaches
in open source can refer to the material, share it with others, and help us to
scale this to others.

Here's a rough look at the outline of some of that material. In time I hope we
can prepare a version of these docs to share with the world...

```
- General Information
  - What exactly is Open Source?
  - When and why Open Source
  - Can I use it?
  - Misconceptions
  - Bad Practices
  - Benefits
- Use
  - Overview
  - Security and vulnerability management
  - Copyleft obligations
  - Intellectual Property scanning
  - Code signing
  - Attribution guidelines
  - Business review process
  - Required notice generation
  - Automated registration of use
- Contribute
  - Contribution overview
  - Forking repositories
  - Business review, if required
- Release
  - Release overview
  - Checklist
  - Copyright headers
  - Foster your community
  - Build and publish your project
  - Code signing
  - Business review, if required
- Data and Insights
  - GitHub insights
  - Registrations and request insights
- GitHub information
  - GitHub overview
  - Accounts and linking
  - Repositories
  - Teams
  - Organizations
  - Transferring and migrating repos
  - Service accounts
  - Two-factor authentication
  - Apps, services and integrations
  - Large files, LFS
```

## Monthly newsletter

The team prepares a monthly newsletter to all interested parties in the company,
including all linked GitHub users, with a distribution north of 25,000
members. As a low-frequency resource, the hope is that the newsletter helps
provide useful information without inundating teams.

Typical newsletters will include 3-5 topics and updates of note, some data or
graphs and charts of adoption and community health, and the date for the next
open source meetup.

## Open Source Meetup

A monthly gathering on the Microsoft campus (or online), the meetup is a quick
event that starts off with networking, a quick lunch, and then 3-4 speakers
who share their recent open source experiences.

This helps connect people, have frank conversations, and build community.

## Open Source Champs

A cross-company group of people who "get it", these are some of the best open
source minds at Microsoft, who have connections, experience, data, and can help
drive best practices and advise on situations.

The champs primarily get involved in a specific discussion list in the company
today, but hopefully in time they will also be able to help share information
with their organizations, and build a two-way conversation channel with more
stakeholders and businesses across the company.

## Internal support

Our OSPO staffs an internal support experience, looking through internal mail
support options, a Teams channel, and other places, to help support needs as
they come up.

The most common issues tend to be helping people find the documentation for what
they are looking to do, pointing them at the GitHub account linking experience or
new repo wizard, or helping answer policy clarifications and questions.

Not all questions can be answered by OSPO - we do at times need people to reach
out to their legal contact for their organization to support their request.

It is also super important to us that we update internal docs and tools when
we learn of gaps or improvements that can be made, so that the next group of
people with the same need will not need an escalation or support incident to
help answer their question.

## Executive council and briefings

Appointed executives from across Microsoft's businesses make up the majority
of the "OSS Exec Council" that meets at least quarterly to discuss progress on
evolving the culture, being available to advise how their groups are contributing
to open source, and otherwise helping provide a conduit with leadership, the
open source champs, and our open source office. In many ways, this group is the
"board of directors" of our OSPO team and we look forward to helping to tackle
whatever is next as a company in this space.

Having this in place helps us take the temperature of leadership of where to spend
our effort and how to think about complicated issues and how to make things
friction-free for our engineering teams who want to contribute to and use
open source everywhere.

# Learnings

We've learned a lot, and continue to learn as we
scale the open source adoption across the company. Many of the specifics learnings
I've had relate to how we operate at scale, how much we can set teams free with
tools and access, and how to help others learn from the experiences.

Just a few short stories...

## GitHub API lessons

We are excellent users/abusers of the GitHub API. We've learned to be
nice and want others to be nice, too.

### User renames

Most [GitHub REST API](https://developer.github.com/v3/) calls that operate
on users or with users tend to take the GitHub *username* as opposed to their
*user ID*.

GitHub allows users to change their username, which means that if you are not
also validating what their current username is, you could find that a few API
calls are not working for a particular set of users who have changed their
usernames.

There is a GitHub API that can take a GitHub user ID and provide you the current
user information response, so you can hit that occassionally, such as in a daily
job which also respects e-tags and caches responses, to make sure you have the
accurate username before calling operational APIs.

At scale, we tend to see about 25 user renames per week at Microsoft today.

### Rate Limiting and being a good citizen

The GitHub API's [conditional request](https://developer.github.com/v3/#conditional-requests) guidance
is good, but many libraries or users of their APIs do not seem to use them by
default.

As long as you keep a cached version of the entities you request, you can use
the e-tag and an `If-None-Match` header to help reduce your load on the rate
limits for GitHub. A request with the existing e-tag, to check if the entity
has changed, will not count against your rolling API limit if it has not changed.

It's great seeing more and more libraries such as [octokit/rest.js](https://github.com/octokit/rest.js)
supporting this concept in various ways, or having extensibility for it.

## Painpoints at scale

### Two-factor authentication

A surprising amount of our internal support traffic comes from employees who
unfortunately lose access to their GitHub accounts.

Since we require our users to use GitHub's two-factor authentication, and this
is a separate two-factor system than the Azure Active Directory multi-factor
auth that our employees also use, it's easy for people to get confused, or to
lose access to the GitHub side of things.

Thankfully, GitHub does a great job of helping remind people to save their
two-factor authentication codes and to encourage other technology such as the use
of U2F devices.

I strongly recommend that everyone have a YubiKey to help make things easier when
using GitHub on a daily basis.

**Everytime a new iPhone model comes out,** I see our account support volume spike... a lot of
people use two-factor authentication apps on their phone, but then forget to
store their backup codes or anticipate that wiping their phone and upgrading to a new
one may not always restore what they think it may.

### Massive teams

**We had our own "Bedlam" incident last year**... we had a GitHub team inside
an organization which was called "All Employees", to make it easy to quickly
give access to private repos ahead of the launch of new work at events.

The idea is that as long as you give 'all employees' read access to the repo, they
can then fork and submit pull requests, making it easier than trying to figure out
what teams may grant them the rights they need. It also encourages the more open
contribution model.

So, [GitHub Team Discussions](https://help.github.com/en/articles/about-team-discussions) shipped in late
2017 and essentially were not very frequently used by our open source teams for
quite some time.

Finally, one day in early 2019, [it finally happened](https://www.businessinsider.com/microsoft-employee-github-reply-all-email-storm-2019-1)...

... someone posted a message to the "all employees in this org" team discussion,
immediately going out to a lot of people ... and then someone posted about how
to update your notification settings ... and then it spiraled out from there.

Along the way we learned a few things:

- People learned about GitHub discussions
- We may have found a few minor bugs in the notification settings on GitHub that were corrected
- We realized there are downsides to _massive_ teams
- We had some fun, too

Old time Microsoft people smiled a lot. Bedlam was a classic Microsoft learning
lesson. It's fun that we can still have similar experiences with the modern
developer toolkit, too...

### Team vs Individual repo permissions

Whenever possible we _strongly encourage_ that the repositories that Microsoft
governs use team permissions instead of granting individual permissions.

GitHub Teams support multiple team maintainers, helping projects evolve over
time, and making it easier to keep access and admin permission assigned as
needed.

We've had to do a lot of user education on this topic: if someone opens a support
ticket needing access permissions, we will never grant them individual permissions
("Collaborator" on GitHub) to a repo, but instead will ask them to help us find
or create a new Team on GitHub for that permission assignment to go to.

This helps keep things sane. Very sane.

### Transparency around permissions

Our GitHub management portal shows all employees all the permissions for teams,
including secret teams. Since we are focused on enabling open source on GitHub,
this helps answer questions people have about who has access to administer or
change settings on a repo and reduces support volume.

On GitHub you can natively see, given a team, which repos and permissions it
has, if you are a member of the org. However, you cannot see easily from a given
repo who the teams are.

Transparent data in the portal also helps reduce support costs around the "404 these aren't the droids you are looking for"
issue: since GitHub will return a 404 for a repo that an org member does not have
access to, we used to get a decent amount of support traffic from people asking
if the URL they were sent by a team member was real or not.

### Paying GitHub

Before we spent a few billion dollars on GitHub, we had paid GitHub organization accounts
at various pricing tiers for our open source GitHub orgs: we needed private repo access for people getting
ready to release their open source.

GitHub offered a really useful annual invoice payment method, so instead of having
to worry about using a corporate card or other payment method each month, we would
just submit a single payment for a set of GitHub orgs, then process that for
payment. GitHub sales was super helpful and friendly.

The only minor issue we've had with this is the few times that we had to make
changes to the LFS data packs for an org during the year... we would solve this
by approving the purchase order for GitHub to include some additional buffer, so
that GitHub sales could just invoice us for the additional data packs as needed.

Before we used the invoice payment method, we did use corporate credit cards as
needed and approved by our finance team; it was nice that we could associate a
Billing Manager or managers to the orgs to help manage that without having to
worry about permission to be org owners or control the resource itself.

Kudos to the friendly GitHub sales and their supporting staff - they were always
willing to jump on a Zoom video conference call and work through the details, such as
when we were signing the Corporate Terms of Service agreement for some of our orgs.

### Org chart proliferation

Many Microsoft teams love to ship the org chart, but when it comes to reinforcing
Microsoft's open source releases, we prefer all repos to go in our few main
organizations.

This also helps make it easier for engineers to get going: they do not need to
identify both an org and a team to work on a repo, they just need to know the
repo name or team details.

By policy and reinforced in our tooling and other systems, we have asked people
to just use the official Microsoft GitHub org since early 2017.

This has been super important by providing a really straightforward way for people
to get access and not worry about cross-org permissions or finding things. We
also know that product names and teams change so often that these things just
would not scale. While the GitHub rename features provide some flexibility to
orgs and repos, we would prefer not to change too many things at once.

Newer GitHub features such as an [enterprise account](https://github.blog/2019-05-23-build-like-an-open-source-community-with-github-enterprise/)
announced in May sound really useful to help address this in the future: if you
can combine compliance and billing together, perhaps it will be easier to have
additional organizations where it makes sense.

## Human challenges

We're continually learning new things.

### Products vs Projects

Microsoft is super crisp on the requirements to ship products and services: the
[Microsoft Security Development Lifecycle (SDL)](https://www.microsoft.com/en-us/securityengineering/sdl)
helps team to be mindful of security and how to build and ship software.

As a company, our products also have requirements around code signing, packaging,
localization, globalization, servicing, accessibility, etc.

Shipping an open source code project (a _repo_) is a little less involved, but teams
still need to do the right thing.

Our policies around releasing source code are more about business purpose and approval,
making sure governance information and LICENSE files and READMEs are in place, and that
teams are ready to support, build and evolve a friendly open community.

We've had a few learning situations where teams thoughts that the full set of requirements
to release a product - such as localizing in many languages - were required to release
an open source repo.

For now, we emphasize to teams that projects are not products, but often, they compliment
one another, and sometimes, they literally are the same thing.

### Forking

Forking is a big deal in the open source world. There are times where a fork is the
right evolution or move for a community to evolve, but we've found that some teams view
forks as the way to contribute upstream.

For example: if someone wants to contribute to CLA Assistant, one approach would be to
fork the repo to their _individual_ GitHub account, and then to submit a pull request to
that upstream project. Another approach would be to fork the project to the official Microsoft
organization, prepare changes, and then submit it as a pull request.

While the second example
makes it clear that this is very much a Microsoft contribution, it creates confusion, because
Microsoft just wants to participate in the upstream project, and not fork it in any hard way.

We strongly encourage teams to simply fork and submit pull requests, the GitHub way, from
their individual accounts, not from the official organization account.

We want teams to always contribute to the upstream when possible and only fork as a last resort.

### Support volume (e-mail)

Since we set the e-mail address opensource@microsoft.com as the e-mail address associated
with the official Microsoft organization on GitHub, we get _a lot_ of e-mail traffic from
people looking for help with issues and products.

Within GitHub, if you're browsing a repo and click "Contact GitHub" in the footer of the web
page, it essentially asks whether you are looking to report a GitHub issue or an issue with
the repo. This helps reduce issue/support traffic to GitHub for open source repos.

GitHub then offers the e-mail address associated with the SUPPORT files for the repo, or falls
back to the org-wide e-mail address. So... we get a lot of e-mail.

We've learned to improve spam filters and use templates and work to address issues, but
we do get a lot of mail.

### People want more open source from us!

On the entertaining side, many passionate users of long-time Microsoft software regularly
write in to ask us to open source their favorite projects...

- Flight Simulator
- Microsoft Money
- Age of Empies
- our operating system

It's great that people really want to see this, but I think a lot of folks do not always
understand that commercial software often has many dependencies or licensed components
that may not be open source, or the code requires a very specialized build environment,
etc.

I do love seeing the historical releases to share code, such as the
[original winfile.exe](https://github.com/microsoft/winfile) or
old-school [MS-DOS 1.25 and 2.0](https://github.com/microsoft/MS-DOS)! Hopefully
teams will find the time to share when it makes sense. It's also a reality that historical
software releases are not a place that will be easy to build an active collaborative
community around unless a clean mechanism exists to release and build modern bits.

# Looking forward

## New GitHub features

As outlined in [Build like an open source community with GitHub Enterprise](https://github.blog/2019-05-23-build-like-an-open-source-community-with-github-enterprise/), Mario Rodriguez from
GitHub highlights how the features that help make GitHub great for open source can
also be super useful for any organization.

We've started adopting GitHub Enterprise Cloud for more of our open source
organizations and I'm excited to see what our engineering teams will do with
these new capabilities.

A few capabilities in particular that we're starting to use include:

### New Maintainer roles

x

New maintainer and etc. roles for work items

### Transferring issues between repos

Ability to transfer issues between repos

### Audit logs

Audit logs

## Playbooks and sharing

As a company we will continue to work to evolve our take on a "maturity model" for
open source organizations, and I can't wait to see what is next.

As we develop more playbooks and resources, we will try and share as much as we can,
to help others in the industry learn from us.

## Identifying contribution opportunities

We are starting to look at ways to draw attention to contribution opportunities, such
as highlighting [https://opensource.microsoft.com/explore](up-for-grabs issues across our releases),
and also recognizing when our employees contribute to open projects outside control of the
company, too.

By updating the _opensource.microsoft.com_ site, we hope to be able to tell good
stories and share useful information about what our teams are up to.

# Open Source Resources

Here are open source GitHub repos mentioned in this post. Check them out!

- [cla-assistant/cla-assistant](https://github.com/cla-assistant/cla-assistant)
- [amzn/oss-attribution-builder](https://github.com/amzn/oss-attribution-builder)
- [clearlydefined/crawler](https://github.com/clearlydefined/crawler)
- [todogroup/repolinter](https://github.com/todogroup/repolinter)
- [clearlydefined/curated-data](https://github.com/clearlydefined/curated-data)
- [microsoft/opensource-portal](https://github.com/Microsoft/opensource-portal)
- [microsoft/ghcrawler](https://github.com/microsoft/ghcrawler)
- [fossology/fossology](https://github.com/fossology/fossology)
- [nexB/scancode-toolkit](https://github.com/nexB/scancode-toolkit)
- [licensee/licensee](https://github.com/licensee/licensee)
- [octokit/rest.js](https://github.com/octokit/rest.js)

Hope this helps,

<i>Jeff Wilcox<br />
Principal Software Engineer<br />
Microsoft Open Source Programs Office</i>
